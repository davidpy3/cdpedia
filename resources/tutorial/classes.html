<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>10. Clases &mdash; Tutorial de Python v2.6.2 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '2.6.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Tutorial de Python v2.6.2 documentation" href="index.html" />
    <link rel="next" title="11. Pequeño paseo por la Biblioteca Estándar" href="stdlib.html" />
    <link rel="prev" title="9. Errores y excepciones" href="errors.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="stdlib.html" title="11. Pequeño paseo por la Biblioteca Estándar"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="errors.html" title="9. Errores y excepciones"
             accesskey="P">anterior</a> |</li>
        <li><a href="contenido.html">Tutorial de Python v2.6.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="clases">
<span id="tut-classes"></span><h1>10. Clases<a class="headerlink" href="#clases" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El mecanismo de clases de Python agrega clases al lenguaje con un mínimo de
nuevas sintaxis y semánticas.  Es una mezcla de los mecanismos de clase
encontrados en C++ y Modula-3.  Como es cierto para los módulos, las clases en
Python no ponen una barrera absoluta entre la definición y el usuario, sino que
más bien se apoya en la cortesía del usuario de no &#8220;forzar la definición&#8221;.  Sin
embargo, se mantiene el poder completo de las características más importantes
de las clases: el mecanismo de la herencia de clases permite múltiples clases
base, una clase derivada puede sobreescribir cualquier método de su(s) clase(s)
base, y un método puede llamar al método de la clase base con el mismo nombre.
Los objetos pueden tener una cantidad arbitraria de datos.</p>
<p>En terminología de C++, todos los miembros de las clases (incluyendo los
miembros de datos), son <em>públicos</em>, y todas las funciones miembro son
<em>virtuales</em>.  Como en Modula-3, no hay atajos para hacer referencia a los
miembros del objeto desde sus métodos: la función método se declara con un
primer argumento explícito que representa al objeto, el cual se provee
implícitamente por la llamada.  Como en Smalltalk, las clases mismas son
objetos.  Esto provee una semántica para importar y renombrar.  A diferencia
de C++ y Modula-3, los tipos de datos integrados pueden usarse como clases
base para que el usuario los extienda.  También, como en C++ pero a
diferencia de Modula-3, la mayoría de los operadores integrados con
sintaxis especial (operadores aritméticos, de subíndice, etc.) pueden ser
redefinidos por instancias de la clase.</p>
<p>(Sin haber una terminología universalmente aceptada sobre clases, haré uso
ocasional de términos de Smalltalk y C++.  Usaría términos de Modula-3, ya que
su semántica orientada a objetos es más cercana a Python que C++, pero no
espero que muchos lectores hayan escuchado hablar de él).</p>
<div class="section" id="unas-palabras-sobre-nombres-y-objetos">
<span id="tut-object"></span><h2>10.1. Unas palabras sobre nombres y objetos<a class="headerlink" href="#unas-palabras-sobre-nombres-y-objetos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos tienen individualidad, y múltiples nombres (en muchos ámbitos)
pueden vincularse al mismo objeto.  Esto se conoce como <em>aliasing</em> en otros
lenguajes.  Normalmente no se aprecia esto a primera vista en Python, y puede
ignorarse sin problemas cuando se maneja tipos básicos inmutables (números,
cadenas, tuplas).  Sin embargo, el <em>aliasing</em>, o renombrado,  tiene un efecto
posiblemente sorpresivo sobre la semántica de código Python que involucra
objetos mutables como listas, diccionarios, y la mayoría de otros tipos.  Esto
se usa normalmente para beneficio del programa, ya que los renombres funcionan
como punteros en algunos aspectos.  Por ejemplo, pasar un objeto es barato ya
que la implementación solamente pasa el puntero; y si una función modifica el
objeto que fue pasado, el que la llama verá el cambio; esto elimina la
necesidad de tener dos formas diferentes de pasar argumentos, como en Pascal.</p>
</div>
<div class="section" id="alcances-y-espacios-de-nombres-en-python">
<span id="tut-scopes"></span><h2>10.2. Alcances y espacios de nombres en Python<a class="headerlink" href="#alcances-y-espacios-de-nombres-en-python" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Antes de ver clases, primero debo decirte algo acerca de las reglas de alcance
de Python.  Las definiciones de clases hacen unos lindos trucos con los
espacios de nombres, y necesitás saber cómo funcionan los alcances y espacios
de nombres para entender por completo cómo es la cosa.  De paso, los
conocimientos en este tema son útiles para cualquier programador Python
avanzado.</p>
<p>Comencemos con unas definiciones.</p>
<p>Un <em>espacio de nombres</em> es una relación de nombres a objetos.  Muchos espacios
de nombres están implementados en este momento como diccionarios de Python,
pero eso no se nota para nada (excepto por el desempeño), y puede cambiar en el
futuro.  Como ejemplos de espacios de nombres tenés: el conjunto de nombres
incluidos (funciones como <tt class="xref docutils literal"><span class="pre">abs()</span></tt>, y los nombres de excepciones
integradas); los nombres globales en un módulo; y los nombres locales en la
invocación a una función.  Lo que es importante saber de los espacios de
nombres es que no hay relación en absoluto entre los nombres de espacios de
nombres distintos; por ejemplo, dos módulos diferentes pueden tener definidos
los dos una función <tt class="docutils literal"><span class="pre">maximizar</span></tt> sin confusión; los usuarios de los módulos
deben usar el nombre del módulo como prefijo.</p>
<p>Por cierto, yo uso la palabra <em>atributo</em> para cualquier cosa después de un
punto; por ejemplo, en la expresión <tt class="docutils literal"><span class="pre">z.real</span></tt>, <tt class="docutils literal"><span class="pre">real</span></tt> es un atributo del
objeto <tt class="docutils literal"><span class="pre">z</span></tt>.  Estrictamente hablando, las referencias a nombres en módulos son
referencias a atributos: en la expresión <tt class="docutils literal"><span class="pre">modulo.funcion</span></tt>, <tt class="docutils literal"><span class="pre">modulo</span></tt> es un
objeto módulo y <tt class="docutils literal"><span class="pre">funcion</span></tt> es un atributo de éste.  En este caso hay una
relación directa entre los atributos del módulo y los nombres globales
definidos en el módulo: ¡están compartiendo el mismo espacio de nombres! <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<p>Los atributos pueden ser de sólo lectura, o de escritura.  En el último caso es
posible la asignación a atributos.  Los atributos de módulo pueden escribirse:
<tt class="docutils literal"><span class="pre">modulo.la_respuesta</span> <span class="pre">=</span> <span class="pre">42</span></tt>.  Los atributos de escritura se pueden borrar
también con la instrucción <tt class="xref docutils literal"><span class="pre">del</span></tt>.  Por ejemplo,
<tt class="docutils literal"><span class="pre">del</span> <span class="pre">modulo.la_respuesta</span></tt> va a eliminar el atributo <tt class="xref docutils literal"><span class="pre">la_respuesta</span></tt> del
objeto con nombre <tt class="docutils literal"><span class="pre">modulo</span></tt>.</p>
<p>Los espacios de nombres se crean en diferentes momentos y con diferentes
tiempos de vida.  El espacio de nombres que contiene los nombres incluidos se
crea cuando se inicia el intérprete, y nunca se borra.  El espacio de nombres
global de un módulo se crea cuando se lee la definición de un módulo;
normalmente, los espacios de nombres de módulos también duran hasta que el
intérprete finaliza.  Las instrucciones ejecutadas en el nivel de llamadas
superior del intérprete, ya sea desde un script o interactivamente, se
consideran parte del módulo llamado <tt class="xref docutils literal"><span class="pre">__main__</span></tt>, por lo tanto tienen su
propio espacio de nombres global.  (Los nombres incluidos en realidad también
viven en un módulo; este se llama <tt class="xref docutils literal"><span class="pre">__builtin__</span></tt>.)</p>
<p>El espacio de nombres local a una función se crea cuando la función es llamada,
y se elimina cuando la función retorna o lanza una excepción que no se maneje
dentro de la función.  (Podríamos decir que lo que pasa en realidad es que ese
espacio de nombres se &#8220;olvida&#8221;.)  Por supuesto, las llamadas recursivas tienen
cada una su propio espacio de nombres local.</p>
<p>Un <em>alcance</em> es una región textual de un programa en Python donde un espacio de
nombres es accesible directamente.  &#8220;Accesible directamente&#8221; significa que una
referencia sin calificar a un nombre intenta encontrar dicho nombre dentro del
espacio de nombres.</p>
<p>Aunque los alcances se determinan estáticamente, se usan dinámicamente. En
cualquier momento durante la ejecución hay por lo menos cuatro alcances
anidados cuyos espacios de nombres son directamente accesibles:</p>
<blockquote>
<ul class="simple">
<li>el ámbito interno, donde se busca primero, contiene los nombres locales</li>
<li>los espacios de nombres de las funciones anexas, en las cuales se busca
empezando por el alcance adjunto más cercano, contiene los nombres no
locales pero también los no globales</li>
<li>el ámbito anteúltimo contiene  los nombres globales del módulo actual</li>
<li>el alcance exterior (donde se busca al final) es el espacio de nombres que
contiene los nombres incluidos</li>
</ul>
</blockquote>
<p>Si un nombre se declara como global, entonces todas las referencias y
asignaciones al mismo van directo al alcance intermedio que contiene los
nombres globales del módulo.  De otra manera, todas las variables que se
encuentren fuera del alcance interno son de sólo lectura (un intento de
escribir a esas variables simplemente crea una <em>nueva</em> variable en el alcance
interno, dejando intacta la variable externa del mismo nombre).</p>
<p>Habitualmente, el alcance local referencia los nombres locales de la función
actual.  Fuera de una función, el alcance local referencia al mismo espacio de
nombres que el alcance global: el espacio de nombres del módulo. Las
definiciones de clases crean un espacio de nombres más en el alcance local.</p>
<p>Es importante notar que los alcances se determinan textualmente: el alcance
global de una función definida en un módulo es el espacio de nombres de ese
módulo, no importa desde dónde o con qué alias se llame a la función.  Por otro
lado, la búsqueda de nombres se hace dinámicamente, en tiempo de ejecución;
sin embargo, la definición del lenguaje está evolucionando a hacer resolución
de nombres estáticamente, en tiempo de &#8220;compilación&#8221;, ¡así que no te confíes de
la resolución de nombres dinámica! (De hecho, las variables locales ya se
determinan estáticamente.)</p>
<p>Una peculiaridad especial de Python es que, si no hay una declaración
<tt class="xref docutils literal"><span class="pre">global</span></tt> o <tt class="xref docutils literal"><span class="pre">nonlocal</span></tt> en efecto, las asignaciones a nombres
siempre van al alcance interno.  Las asignaciones no copian datos, solamente
asocian nombres a objetos.  Lo mismo cuando se borra: la instrucción <tt class="docutils literal"><span class="pre">del</span> <span class="pre">x</span></tt>
quita la asociación de <tt class="docutils literal"><span class="pre">x</span></tt> del espacio de nombres referenciado por el alcance
local.  De hecho, todas las operaciones que introducen nuevos nombres usan el
alcance local: en particular, las instrucciones <tt class="xref docutils literal"><span class="pre">import</span></tt> y las
definiciones de funciones asocian el módulo o nombre de la función al espacio
de nombres en el alcance local.  (La instrucción <tt class="xref docutils literal"><span class="pre">global</span></tt> puede usarse
para indicar que ciertas variables viven en el alcance global.)</p>
</div>
<div class="section" id="un-primer-vistazo-a-las-clases">
<span id="tut-firstclasses"></span><h2>10.3. Un primer vistazo a las clases<a class="headerlink" href="#un-primer-vistazo-a-las-clases" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las clases introducen un poquito de sintaxis nueva, tres nuevos tipos de
objetos y algo de semántica nueva.</p>
<div class="section" id="sintaxis-de-definicion-de-clases">
<span id="tut-classdefinition"></span><h3>10.3.1. Sintaxis de definición de clases<a class="headerlink" href="#sintaxis-de-definicion-de-clases" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La forma más sencilla de definición de una clase se ve así:</p>
<div class="highlight-python"><pre>class Clase:
    &lt;declaración-1&gt;
    .
    .
    .
    &lt;declaración-N&gt;</pre>
</div>
<p>Las definiciones de clases, al igual que las definiciones de funciones
(instrucciones <tt class="xref docutils literal"><span class="pre">def</span></tt>) deben ejecutarse antes de que tengan efecto
alguno.  (Es concebible poner una definición de clase dentro de una rama de un
<tt class="xref docutils literal"><span class="pre">if</span></tt>, o dentro de una función.)</p>
<p>En la práctica, las declaraciones dentro de una clase son definiciones de
funciones, pero otras declaraciones son permitidas, y a veces resultan útiles;
veremos esto más adelante.  Las definiciones de funciones dentro de una
clase normalmente tienen una lista de argumentos peculiar, dictada por las
convenciones de invocación de métodos; a esto también lo veremos más adelante.</p>
<p>Cuando se ingresa una definición de clase, se crea un nuevo espacio de nombres,
el cual se usa como alcance local; por lo tanto, todas las asignaciones a
variables locales van a este nuevo espacio de nombres.  En particular, las
definiciones de funciones asocian el nombre de las funciones nuevas allí.</p>
<p>Cuando una definición de clase se finaliza normalmente se crea un
<em>objeto clase</em>.  Básicamente, este objeto envuelve los contenidos del espacio
de nombres creado por la definición de la clase; aprenderemos más acerca de los
objetos clase en la sección siguiente.  El alcance local original (el que tenía
efecto justo antes de que ingrese la definición de la clase) es restablecido, y
el objeto clase se asocia allí al nombre que se le puso a la clase en el
encabezado de su definición (<tt class="xref docutils literal"><span class="pre">Clase</span></tt> en el ejemplo).</p>
</div>
<div class="section" id="objetos-clase">
<span id="tut-classobjects"></span><h3>10.3.2. Objetos clase<a class="headerlink" href="#objetos-clase" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los objetos clase soportan dos tipos de operaciones: hacer referencia a
atributos e instanciación.</p>
<p>Para <em>hacer referencia a atributos</em> se usa la sintaxis estándar de todas las
referencias a atributos en Python: <tt class="docutils literal"><span class="pre">objeto.nombre</span></tt>.  Los nombres de atributo
válidos son todos los nombres que estaban en el espacio de nombres de la clase
cuando ésta se creó.  Por lo tanto, si la definición de la clase es así:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MiClase</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Simple clase de ejemplo&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;hola mundo&#39;</span>
</pre></div>
</div>
<p>...entonces <tt class="docutils literal"><span class="pre">MiClase.i</span></tt> y <tt class="docutils literal"><span class="pre">MiClase.f</span></tt> son referencias de atributos válidas,
que devuelven un entero y un objeto función respectivamente.  Los atributos de
clase también pueden ser asignados, o sea que podés cambiar el valor de
<tt class="docutils literal"><span class="pre">MiClase.i</span></tt> mediante asignación.  <tt class="xref docutils literal"><span class="pre">__doc__</span></tt> también es un atributo
válido, que devuelve la documentación asociada a la clase:
<tt class="docutils literal"><span class="pre">&quot;Simple</span> <span class="pre">clase</span> <span class="pre">de</span> <span class="pre">ejemplo&quot;</span></tt>.</p>
<p>La <em>instanciación</em> de clases usa la notación de funciones.  Hacé de cuenta que
el objeto de clase es una función sin parámetros que devuelve una nueva
instancia de la clase.  Por ejemplo (para la clase de más arriba):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">MiClase</span><span class="p">()</span>
</pre></div>
</div>
<p>...crea una nueva <em>instancia</em> de la clase y asigna este objeto a la variable
local <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>La operación de instanciación (&#8220;llamar&#8221; a un objeto clase) crea un objeto
vacío.  Muchas clases necesitan crear objetos con instancias en un estado
inicial particular.  Por lo tanto una clase puede definir un método especial
llamado <tt class="xref docutils literal"><span class="pre">__init__()</span></tt>, de esta forma:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">datos</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>Cuando una clase define un método <tt class="xref docutils literal"><span class="pre">__init__()</span></tt>, la instanciación de la
clase automáticamente invoca a <tt class="xref docutils literal"><span class="pre">__init__()</span></tt> para la instancia recién
creada.  Entonces, en este ejemplo, una instancia nueva e inicializada se puede
obtener haciendo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">MiClase</span><span class="p">()</span>
</pre></div>
</div>
<p>Por supuesto, el método <tt class="xref docutils literal"><span class="pre">__init__()</span></tt> puede tener argumentos para mayor
flexibilidad.  En ese caso, los argumentos que se pasen al operador de
instanciación de la clase van a parar al método <tt class="xref docutils literal"><span class="pre">__init__()</span></tt>.  Por
ejemplo,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complejo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partereal</span><span class="p">,</span> <span class="n">parteimaginaria</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">partereal</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">parteimaginaria</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complejo</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</div>
<div class="section" id="objetos-instancia">
<span id="tut-instanceobjects"></span><h3>10.3.3. Objetos instancia<a class="headerlink" href="#objetos-instancia" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora, ¿Qué podemos hacer con los objetos instancia?  La única operación que
es entendida por los objetos instancia es la referencia de atributos.  Hay dos
tipos de nombres de atributos válidos, atributos de datos y métodos.</p>
<p>Los <em>atributos de datos</em> se corresponden con las &#8220;variables de instancia&#8221; en
Smalltalk, y con las &#8220;variables miembro&#8221; en C++.  Los atributos de datos no
necesitan ser declarados; tal como las variables locales son creados la primera
vez que se les asigna algo.  Por ejemplo, si <tt class="docutils literal"><span class="pre">x</span></tt> es la instancia de
<tt class="xref docutils literal"><span class="pre">MiClase</span></tt> creada más arriba, el siguiente pedazo de código va a
imprimir el valor <tt class="docutils literal"><span class="pre">16</span></tt>, sin dejar ningún rastro:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="o">.</span><span class="n">contador</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">contador</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">contador</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">contador</span> <span class="o">*</span> <span class="mi">2</span>
<span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">contador</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">contador</span>
</pre></div>
</div>
<p>El otro tipo de atributo de instancia es el <em>método</em>.  Un método es una función
que &#8220;pertenece a&#8221; un objeto.  En Python, el término método no está limitado a
instancias de clase: otros tipos de objetos pueden tener métodos también.  Por
ejemplo, los objetos lista tienen métodos llamados append, insert, remove,
sort, y así sucesivamente.  Pero, en la siguiente explicación, usaremos el
término método para referirnos exclusivamente a métodos de objetos instancia de
clase, a menos que se especifique explícitamente lo contrario.</p>
<p id="index-56">Los nombres válidos de métodos de un objeto instancia dependen de su clase.
Por definición, todos los atributos de clase que son objetos funciones definen
métodos correspondientes de sus instancias.  Entonces, en nuestro ejemplo,
<tt class="docutils literal"><span class="pre">x.f</span></tt> es una referencia a un método válido, dado que <tt class="docutils literal"><span class="pre">MiClase.f</span></tt> es una
función, pero <tt class="docutils literal"><span class="pre">x.i</span></tt> no lo es, dado que <tt class="docutils literal"><span class="pre">MiClase.i</span></tt> no lo es.  Pero <tt class="docutils literal"><span class="pre">x.f</span></tt>
no es la misma cosa que <tt class="docutils literal"><span class="pre">MiClase.f</span></tt>; es un <em>objeto método</em>, no un objeto
función.</p>
</div>
<div class="section" id="objetos-metodo">
<span id="tut-methodobjects"></span><h3>10.3.4. Objetos método<a class="headerlink" href="#objetos-metodo" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Generalmente, un método es llamado luego de ser vinculado:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>En el ejemplo <tt class="xref docutils literal"><span class="pre">MiClase</span></tt>, esto devuelve la cadena <tt class="docutils literal"><span class="pre">'hola</span> <span class="pre">mundo'</span></tt>.
Pero no es necesario llamar al método justo en ese momento: <tt class="docutils literal"><span class="pre">x.f</span></tt> es
un objeto método, y puede ser guardado y llamado más tarde.  Por ejemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">xf</span><span class="p">()</span>
</pre></div>
</div>
<p>...continuará imprimiendo <tt class="docutils literal"><span class="pre">hola</span> <span class="pre">mundo</span></tt> hasta el fin de los días.</p>
<p>¿Qué sucede exactamente cuando un método es llamado?  Debés haber notado que
<tt class="docutils literal"><span class="pre">x.f()</span></tt> fue llamado más arriba sin ningún argumento, a pesar de que la
definición de función de <tt class="xref docutils literal"><span class="pre">f()</span></tt> especificaba un argumento.  ¿Qué pasó con
ese argumento?  Seguramente Python levanta una excepción cuando una función que
requiere un argumento es llamada sin ninguno, aún si el argumento no es
utilizado...</p>
<p>De hecho, tal vez hayas adivinado la respuesta: lo que tienen de especial los
métodos es que el objeto es pasado como el primer argumento de la función.
En nuestro ejemplo, la llamada <tt class="docutils literal"><span class="pre">x.f()</span></tt> es exactamente equivalente a
<tt class="docutils literal"><span class="pre">MiClase.f(x)</span></tt>.  En general, llamar a un método con una lista de <em>n</em>
argumentos es equivalente a llamar a la función correspondiente con una lista
de argumentos que es creada insertando el objeto del método antes del primer
argumento.</p>
<p>Si aún no comprendés como funcionan los métodos, un vistazo a la implementación
puede ayudar a clarificar este tema.  Cuando se hace referencia un atributo de
instancia y no es un atributo de datos, se busca dentro de su clase.  Si el
nombre denota un atributo de clase válido que es un objeto función, un método
objeto es creado, juntando (punteros a) el objeto instancia y el objeto función
que ha sido encontrado.  Este objeto abstracto creado de esta unión es el
objeto método.  Cuando el objeto método es llamado con una lista de argumentos,
es nuevamente desempaquetado, una lista de argumentos nueva es construida a
partir del objeto instancia y la lista de argumentos original, y el objeto
función es llamado con esta nueva lista de argumentos.</p>
</div>
</div>
<div class="section" id="algunas-observaciones">
<span id="tut-remarks"></span><h2>10.4. Algunas observaciones<a class="headerlink" href="#algunas-observaciones" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los atributos de datos tienen preferencia sobre los métodos con el mismo
nombre; para evitar conflictos de nombre accidentales, que pueden causar
errores difíciles de encontrar en programas grandes, es prudente usar algún
tipo de convención que minimice las posibilidades de dichos conflictos.
Algunas convenciones pueden ser poner los nombres de métodos con mayúsculas,
prefijar los nombres de atributos de datos con una pequeña cadena única (a lo
mejor sólo un guión bajo), o usar verbos para los métodos y sustantivos para
los atributos.</p>
<p>A los atributos de datos los pueden hacer referencia tanto los métodos como los
usuarios (&#8220;clientes&#8221;) ordinarios de un objeto.  En otras palabras, las clases
no se usan para implementar tipos de datos abstractos puros.  De hecho, en
Python no hay nada que haga cumplir el ocultar datos; todo se basa en
convención.  (Por otro lado, la implementación de Python, escrita en C,
puede ocultar por completo detalles de implementación y el control de acceso a
un objeto si es necesario; esto se puede usar en extensiones a Python escritas
en C.)</p>
<p>Los clientes deben usar los atributos de datos con cuidado; éstos pueden
romper invariantes que mantienen los métodos si pisan los atributos de datos.
Observá que los clientes pueden añadir sus propios atributos de datos a una
instancia sin afectar la validez de sus métodos, siempre y cuando se eviten
conflictos de nombres; de nuevo, una convención de nombres puede ahorrar
un montón de dolores de cabeza.</p>
<p>No hay un atajo para hacer referencia a atributos de datos (¡u otros métodos!)
desde dentro de un método.  A mi parecer, esto en realidad aumenta la
legibilidad de los métodos: no existe posibilidad alguna de confundir variables
locales con variables de instancia cuando repasamos un método.</p>
<p>A menudo, el primer argumento de un método se llama <tt class="docutils literal"><span class="pre">self</span></tt> (uno mismo).  Esto
no es nada más que una convención: el nombre <tt class="docutils literal"><span class="pre">self</span></tt> no significa nada en
especial para Python.  Observá que, sin embargo, si no seguís la convención tu
código puede resultar menos legible a otros programadores de Python, y puede
llegar a pasar que un programa <em>navegador de clases</em> pueda escribirse de una
manera que dependa de dicha convención.</p>
<p>Cualquier objeto función que es un atributo de clase define un método para
instancias de esa clase.  No es necesario que el la definición de la función
esté textualmente dentro de la definición de la clase: asignando un objeto
función a una variable local en la clase también está bien.  Por ejemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Función definida fuera de la clase</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;hola mundo&#39;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>Ahora <tt class="docutils literal"><span class="pre">f</span></tt>, <tt class="docutils literal"><span class="pre">g</span></tt> y <tt class="docutils literal"><span class="pre">h</span></tt> son todos atributos de la clase <tt class="xref docutils literal"><span class="pre">C</span></tt> que hacen
referencia a objetos función, y consecuentemente son todos métodos de las
instancias de <tt class="xref docutils literal"><span class="pre">C</span></tt>; <tt class="docutils literal"><span class="pre">h</span></tt> siendo exactamente equivalente a <tt class="docutils literal"><span class="pre">g</span></tt>.
Fijate que esta práctica normalmente sólo sirve para confundir al que lea un
programa.</p>
<p>Los métodos pueden llamar a otros métodos de la instancia usando el argumento
<tt class="docutils literal"><span class="pre">self</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Bolsa</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">agregar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dobleagregar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agregar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agregar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Los métodos pueden hacer referencia a nombres globales de la misma manera que
lo hacen las funciones comunes.  El alcance global asociado a un método es el
módulo que contiene la definición de la clase.  (La clase misma nunca se usa
como un alcance global.)  Si bien es raro encontrar una buena razón para usar
datos globales en un método, hay muchos usos legítimos del alcance global: por
lo menos, las funciones y módulos importados en el alcance global pueden usarse
por los métodos, al igual que las funciones y clases definidas en él.
Habitualmente, la clase que contiene el método está definida en este alcance
global, y en la siguiente sección veremos algunas buenas razones por las que
un método querría hacer referencia a su propia clase.</p>
<p>Todo valor es un objeto, y por lo tanto tiene una <em>clase</em> (también llamado su
<em>tipo</em>). Ésta se almacena como <tt class="docutils literal"><span class="pre">objeto.__class__</span></tt>.</p>
</div>
<div class="section" id="herencia">
<span id="tut-inheritance"></span><h2>10.5. Herencia<a class="headerlink" href="#herencia" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Por supuesto, una característica del lenguaje no sería digna del nombre &#8220;clase&#8221;
si no soportara herencia.  La sintaxis para una definición de clase derivada se
ve así:</p>
<div class="highlight-python"><pre>class ClaseDerivada(ClaseBase):
    &lt;declaración-1&gt;
    .
    .
    .
    &lt;declaración-N&gt;</pre>
</div>
<p>El nombre <tt class="xref docutils literal"><span class="pre">ClaseBase</span></tt> debe estar definido en un alcance que contenga a
la definición de la clase derivada.  En el lugar del nombre de la clase base se
permiten otras expresiones arbitrarias.  Esto puede ser útil, por ejemplo,
cuando la clase base está definida en otro módulo:</p>
<div class="highlight-python"><pre>class ClaseDerivada(modulo.ClaseBase):</pre>
</div>
<p>La ejecución de una definición de clase derivada procede de la misma forma que
una clase base.  Cuando el objeto clase se construye, se tiene en cuenta a la
clase base.  Esto se usa para resolver referencias a atributos: si un atributo
solicitado no se encuentra en la clase, la búsqueda continúa por la clase base.
Esta regla se aplica recursivamente si la clase base misma deriva de alguna
otra clase.</p>
<p>No hay nada en especial en la instanciación de clases derivadas:
<tt class="docutils literal"><span class="pre">ClaseDerivada()</span></tt> crea una nueva instancia de la clase.  Las referencias a
métodos se resuelven de la siguiente manera: se busca el atributo de clase
correspondiente, descendiendo por la cadena de clases base si es necesario, y
la referencia al método es válida si se entrega un objeto función.</p>
<p>Las clases derivadas pueden redefinir métodos de su clase base.  Como los
métodos no tienen privilegios especiales cuando llaman a otros métodos del
mismo objeto, un método de la clase base que llame a otro método definido en la
misma clase base puede terminar llamando a un método de la clase derivada que
lo haya redefinido.  (Para los programadores de C++: en Python todos los
métodos son en efecto <tt class="docutils literal"><span class="pre">virtuales</span></tt>.)</p>
<p>Un método redefinido en una clase derivada puede de hecho querer extender en
vez de simplemente reemplazar al método de la clase base con el mismo nombre.
Hay una manera simple de llamar al método de la clase base directamente:
simplemente llamás a <tt class="docutils literal"><span class="pre">ClaseBase.metodo(self,</span> <span class="pre">argumentos)</span></tt>.  En ocasiones esto
es útil para los clientes también.  (Observá que esto sólo funciona si la clase
base es accesible como <tt class="docutils literal"><span class="pre">CalseBase</span></tt> en el alcance global.)</p>
<p>Python tiene dos funciones integradas que funcionan con herencia:</p>
<ul class="simple">
<li>Usá <tt class="xref docutils literal"><span class="pre">isinstance()</span></tt> para verificar el tipo de una instancia:
<tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></tt> devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt> solo si <tt class="docutils literal"><span class="pre">obj.__class__</span></tt> es
<tt class="xref docutils literal"><span class="pre">int</span></tt> o alguna clase derivada de <tt class="xref docutils literal"><span class="pre">int</span></tt>.</li>
<li>Usá <tt class="xref docutils literal"><span class="pre">issubclass()</span></tt> para comprobar herencia de clase:
<tt class="docutils literal"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></tt> da <tt class="xref docutils literal"><span class="pre">True</span></tt> ya que <tt class="xref docutils literal"><span class="pre">bool</span></tt> es una subclase de
<tt class="xref docutils literal"><span class="pre">int</span></tt>.  Sin embargo, <tt class="docutils literal"><span class="pre">issubclass(unicode,</span> <span class="pre">str)</span></tt> devuelve <tt class="xref docutils literal"><span class="pre">False</span></tt>
porque <tt class="xref docutils literal"><span class="pre">unicode</span></tt> no es una subclase de <tt class="xref docutils literal"><span class="pre">str</span></tt> (solamente tienen
un ancestro en común, <tt class="xref docutils literal"><span class="pre">basestring</span></tt>).</li>
</ul>
<div class="section" id="herencia-multiple">
<span id="tut-multiple"></span><h3>10.5.1. Herencia múltiple<a class="headerlink" href="#herencia-multiple" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Python también soporta una forma limitada de herencia múltiple.  Una definición
de clase con múltiples clases base se ve así:</p>
<div class="highlight-python"><pre>class ClaseDerivada(Base1, Base2, Base3):
    &lt;declaración-1&gt;
    .
    .
    .
    &lt;declaración-N&gt;</pre>
</div>
<p>Para clases de estilo viejo la única regla es buscar en profundidad, de
izquierda a derecha.  Por lo tanto, si un atributo no se encuentra en
<tt class="xref docutils literal"><span class="pre">ClaseDerivada</span></tt>, se busca en <tt class="xref docutils literal"><span class="pre">Base1</span></tt>, luego (recursivamente) en
las clases base de <tt class="xref docutils literal"><span class="pre">Base1</span></tt>, y sólo si no se encuentra allí se lo busca
en <tt class="xref docutils literal"><span class="pre">Base2</span></tt>, y así sucesivamente.</p>
<p>(A algunos la búsqueda en anchura, o sea, buscar en <tt class="xref docutils literal"><span class="pre">Base2</span></tt> y
<tt class="xref docutils literal"><span class="pre">Base3</span></tt> antes que en las clases base de <tt class="xref docutils literal"><span class="pre">Base1</span></tt>, les parece más
natural.  Sin embargo, para esto haría falta que sepas si un atributo en
particular de <tt class="xref docutils literal"><span class="pre">Base1</span></tt> está de hecho definido en <tt class="xref docutils literal"><span class="pre">Base1</span></tt> o en
alguna de sus clases base antes de que puedas entender las consecuencias de un
conflicto de nombres con un atributo de <tt class="xref docutils literal"><span class="pre">Base2</span></tt>.  La regla de buscar
primero en profundidad no hace diferencias entre atributos directos o heredados
de <tt class="xref docutils literal"><span class="pre">Base1</span></tt>.)</p>
<p>Para las clases de <em class="xref">estilo nuevo</em>, el método de resolución de orden
cambia dinámicamente para soportar llamadas cooperativas a <tt class="xref docutils literal"><span class="pre">super()</span></tt>.  Este
enfoque es conocido en otros lenguajes con herencia múltiple como &#8220;llámese al
siguiente método&#8221; y es más poderoso que la llamada al superior que se encuentra
en lenguajes con sólo herencia simple.</p>
<p>Con las clases de estilo nuevo, se necesita el orden dinámico porque todos los
casos de herencia múltiple exhiben una o más relaciones en diamante (cuando se
puede llegar al menos a una de las clases base por distintos caminos desde la
clase de más abajo).  Por ejemplo, todas las clases de nuevo estilo heredan de
<tt class="xref docutils literal"><span class="pre">object</span></tt>, por lo tanto cualquier caso de herencia múltiple provee más de
un camino para llegar a <tt class="xref docutils literal"><span class="pre">object</span></tt>.  Para que las clases base no sean
accedidas más de una vez, el algoritmo dinámico hace lineal el orden de
búsqueda de manera que se preserve el orden de izquierda a derecha especificado
en cada clase, que se llame a cada clase base sólo una vez, y que sea monótona
(lo cual significa que una clase puede tener clases derivadas sin afectar el
orden de precedencia de sus clases bases).  En conjunto, estas propiedades
hacen posible diseñar clases confiables y extensibles con herencia múltiple.
Para más detalles mirá  <a class="reference external" href="http://www.python.org/download/releases/2.3/mro/">http://www.python.org/download/releases/2.3/mro/</a>.</p>
</div>
</div>
<div class="section" id="variables-privadas">
<span id="tut-private"></span><h2>10.6. Variables privadas<a class="headerlink" href="#variables-privadas" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las variables &#8220;privadas&#8221; de instancia que no pueden accederse excepto desde
dentro de un objeto, no existen en Python.  Sin embargo, hay una convención que
se sigue en la mayoría del código Python: un nombre prefijado con un guión bajo
(por ejemplo, <tt class="docutils literal"><span class="pre">_spam</span></tt>) debería tratarse como una parte no pública de la API
(más allá de que sea una función, un método, o un dato).  Debería considerarse
un detalle de implementación y que está sujeto a cambios sin aviso.</p>
<p>Ya que hay un caso de uso válido para los identificadores privados de clase
(a saber: colisión de nombres con nombres definidos en las subclases), hay
un soporte limitado para este mecanismo.  Cualquier identificador con la
forma <tt class="docutils literal"><span class="pre">__spam</span></tt> (al menos dos guiones bajos al principio, como mucho un
guión bajo al final) es textualmente reemplazado por <tt class="docutils literal"><span class="pre">_nombredeclase__spam</span></tt>,
donde <tt class="docutils literal"><span class="pre">nombredeclase</span></tt> es el nombre de clase actual al que se le sacan
guiones bajos del comienzo (si los tuviera).  Se modifica el nombre del
identificador sin importar su posición sintáctica, así que puede ser
usado para definir instancias y variables de clase privadas, métodos, variables
guardadas en globales, y aún variables guardadas en instancias privadas de esta
clase en instancias de <em>otras</em> clases.  Puede ocurrir que se trunque si el
nombre modificado queda con más de 255 caracteres.  Fuera de las clases,
o cuando el nombre de clase consiste solo en guiones bajos, no se modifican los
nombres de identificadores.</p>
<p>Hay que aclarar que las reglas de modificación de nombres están diseñadas
principalmente para evitar accidentes; es posible acceder o modificar una
variable que es considerada como privada.  Esto hasta puede resultar útil en
circunstancias especiales, tales como en el depurador.</p>
<p>Notar que el código pasado a <tt class="docutils literal"><span class="pre">exec</span></tt>, a <tt class="docutils literal"><span class="pre">eval()</span></tt> o a <tt class="docutils literal"><span class="pre">execfile()</span></tt> no
considera que el nombre de clase de la clase que invoca sea la clase actual;
esto es similar al efecto de la sentencia <tt class="docutils literal"><span class="pre">global</span></tt>, efecto que es de
similar manera restringido a código que es compilado en conjunto.  La
misma restricción aplica a <tt class="docutils literal"><span class="pre">getattr()</span></tt>, <tt class="docutils literal"><span class="pre">setattr()</span></tt> y <tt class="docutils literal"><span class="pre">delattr()</span></tt>, así
como cuando se referencia a <tt class="docutils literal"><span class="pre">__dict__</span></tt> directamente.</p>
</div>
<div class="section" id="cambalache">
<span id="tut-odds"></span><h2>10.7. Cambalache<a class="headerlink" href="#cambalache" title="Enlazar permanentemente con este título">¶</a></h2>
<p>A veces es útil tener un tipo de datos similar al &#8220;registro&#8221; de Pascal o la
&#8220;estructura&#8221; de C, que sirva para juntar algunos pocos ítems con nombre.  Una
definición de clase vacía funcionará perfecto:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Empleado</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">juan</span> <span class="o">=</span> <span class="n">Empleado</span><span class="p">()</span> <span class="c"># Crear un registro de empleado vacío</span>

<span class="c"># Llenar los campos del registro</span>
<span class="n">juan</span><span class="o">.</span><span class="n">nombre</span> <span class="o">=</span> <span class="s">&#39;Juan Pistola&#39;</span>
<span class="n">juan</span><span class="o">.</span><span class="n">depto</span> <span class="o">=</span> <span class="s">u&#39;laboratorio de computación&#39;</span>
<span class="n">juan</span><span class="o">.</span><span class="n">salario</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Algún código Python que espera un tipo abstracto de datos en particular
puede frecuentemente recibir en cambio una clase que emula los métodos de aquel
tipo de datos.  Por ejemplo, si tenés una función que formatea algunos
datos a partir de un objeto archivo, podés definir una clase con métodos
<tt class="xref docutils literal"><span class="pre">read()</span></tt> y <tt class="xref docutils literal"><span class="pre">readline()</span></tt> que obtengan los datos de alguna cadena en
memoria intermedia, y pasarlo como argumento.</p>
<p>Los objetos método de instancia tienen atributos también: <tt class="docutils literal"><span class="pre">m.im_self</span></tt> es
el objeto instancia con el método <tt class="xref docutils literal"><span class="pre">m()</span></tt>, y <tt class="docutils literal"><span class="pre">m.im_func</span></tt> es el objeto
función correspondiente al método.</p>
</div>
<div class="section" id="las-excepciones-tambien-son-clases">
<span id="tut-exceptionclasses"></span><h2>10.8. Las excepciones también son clases<a class="headerlink" href="#las-excepciones-tambien-son-clases" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las excepciones definidas por el usuario también son identificadas por clases.
Usando este mecanismo es posible crear jerarquías extensibles de excepciones:</p>
<p>Hay dos nuevas formas (semánticas) válidas para la sentencia <tt class="xref docutils literal"><span class="pre">raise</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">raise</span> <span class="n">Clase</span><span class="p">,</span> <span class="n">instancia</span>

<span class="k">raise</span> <span class="n">instancia</span>
</pre></div>
</div>
<p>En la primera forma, <tt class="docutils literal"><span class="pre">instancia</span></tt> debe ser una instancia de <tt class="xref docutils literal"><span class="pre">Clase</span></tt> o
de una clase derivada de ella.  La segunda forma es una abreviatura de:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">raise</span> <span class="n">instancia</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">instance</span>
</pre></div>
</div>
<p>Una clase en una cláusula <tt class="xref docutils literal"><span class="pre">except</span></tt> es compatible con una excepción si
es de la misma clase o una clase base suya (pero no al revés, una cláusula
except listando una clase derivada no es compatible con una clase base).  Por
ejemplo, el siguiente código imprimirá B, C, D en ese orden:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">c</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">D</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;D&quot;</span>
    <span class="k">except</span> <span class="n">C</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;C&quot;</span>
    <span class="k">except</span> <span class="n">B</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;B&quot;</span>
</pre></div>
</div>
<p>Notar que si la cláusulas <tt class="docutils literal"><span class="pre">except</span></tt> fueran invertidas (dejando <tt class="docutils literal"><span class="pre">except</span> <span class="pre">B</span></tt> al
principio), habría impreso B, B, B; se dispara la primera cláusula <tt class="docutils literal"><span class="pre">except</span></tt>
que coincide.</p>
<p>Cuando se imprime un mensaje de error para una excepción sin atrapar, se
imprime el nombre de la clase de la excepción, luego dos puntos y un espacio y
finalmente la instancia convertida a un string usando la función
integrada <tt class="xref docutils literal"><span class="pre">str()</span></tt>.</p>
</div>
<div class="section" id="iteradores">
<span id="tut-iterators"></span><h2>10.9. Iteradores<a class="headerlink" href="#iteradores" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Es probable que hayas notado que la mayoría de los objetos contenedores pueden
ser recorridos usando una sentencia <tt class="xref docutils literal"><span class="pre">for</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">elemento</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">elemento</span>
<span class="k">for</span> <span class="n">elemento</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">elemento</span>
<span class="k">for</span> <span class="n">clave</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;uno&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;dos&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="k">print</span> <span class="n">clave</span>
<span class="k">for</span> <span class="n">caracter</span> <span class="ow">in</span> <span class="s">&quot;123&quot;</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">caracter</span>
<span class="k">for</span> <span class="n">linea</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;miarchivo.txt&quot;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">linea</span>
</pre></div>
</div>
<p>Este estilo de acceso es limpio, conciso y conveniente.  El uso de iteradores
está impregnado y unifica a Python.  En bambalinas, la sentencia <tt class="xref docutils literal"><span class="pre">for</span></tt>
llama a <tt class="xref docutils literal"><span class="pre">iter()</span></tt> en el objeto contenedor.  La función devuelve un objeto
iterador que define el método <tt class="xref docutils literal"><span class="pre">next()</span></tt> que accede elementos en el
contenedor de a uno por vez.  Cuando no hay más elementos, <tt class="xref docutils literal"><span class="pre">next()</span></tt> levanta
una excepción <tt class="xref docutils literal"><span class="pre">StopIteration</span></tt> que le avisa al bucle del <tt class="xref docutils literal"><span class="pre">for</span></tt> que
hay que terminar.  Este ejemplo muestra como funciona todo esto:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;iterator object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
    <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="nc">StopIteration</span>
</pre></div>
</div>
<p>Habiendo visto la mecánica del protocolo de iteración, es fácil agregar
comportamiento de iterador a tus clases.  Definí un método <tt class="xref docutils literal"><span class="pre">__iter__()</span></tt>
que devuelva un objeto con un método <tt class="xref docutils literal"><span class="pre">next()</span></tt>.  Si la clase define
<tt class="xref docutils literal"><span class="pre">next()</span></tt>, entonces alcanza con que <tt class="xref docutils literal"><span class="pre">__iter__()</span></tt> devuelva <tt class="docutils literal"><span class="pre">self</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Reversa</span><span class="p">:</span>
<span class="gp">... </span>    <span class="s">&quot;Iterador para recorrer una secuencia marcha atrás&quot;</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datos</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">datos</span> <span class="o">=</span> <span class="n">datos</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">indice</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">datos</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indice</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">StopIteration</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">indice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indice</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datos</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indice</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letra</span> <span class="ow">in</span> <span class="n">Reversa</span><span class="p">(</span><span class="s">&#39;spam&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">letra</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</div>
<div class="section" id="generadores">
<span id="tut-generators"></span><h2>10.10. Generadores<a class="headerlink" href="#generadores" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los <em class="xref">generador</em>es son una simple y poderosa herramienta para crear
iteradores.  Se escriben como funciones regulares pero usan la sentencia
<tt class="xref docutils literal"><span class="pre">yield</span></tt> cuando quieren devolver datos.  Cada vez que <tt class="xref docutils literal"><span class="pre">next()</span></tt>
es llamado, el generador continúa desde donde dejó (y recuerda todos los
valores de datos y cual sentencia fue ejecutada última).  Un ejemplo muestra
que los generadores pueden ser muy fáciles de crear:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">reversa</span><span class="p">(</span><span class="n">datos</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">indice</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datos</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">datos</span><span class="p">[</span><span class="n">indice</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letra</span> <span class="ow">in</span> <span class="n">reversa</span><span class="p">(</span><span class="s">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">letra</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>Todo lo que puede ser hecho con generadores también puede ser hecho con
iteradores basados en clases, como se describe en la sección anterior.  Lo
que hace que los generadores sean tan compactos es que los métodos
<tt class="xref docutils literal"><span class="pre">__iter__()</span></tt> y <tt class="xref docutils literal"><span class="pre">next()</span></tt> son creados automáticamente.</p>
<p>Otra característica clave es que las variables locales y el estado de la
ejecución son guardados automáticamente entre llamadas.  Esto hace que la
función sea más fácil de escribir y quede mucho más claro que hacerlo
usando variables de instancia tales como <tt class="docutils literal"><span class="pre">self.indice</span></tt> y <tt class="docutils literal"><span class="pre">self.datos</span></tt>.</p>
<p>Además de la creación automática de métodos y el guardar el estado del
programa, cuando los generadores terminan automáticamente levantan
<tt class="xref docutils literal"><span class="pre">StopIteration</span></tt>.  Combinadas, estas características facilitan
la creación de iteradores, y hacen que no sea más esfuerzo que escribir
una función regular.</p>
</div>
<div class="section" id="expresiones-generadoras">
<span id="tut-genexps"></span><h2>10.11. Expresiones generadoras<a class="headerlink" href="#expresiones-generadoras" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Algunos generadores simples pueden ser codificados concisamente como
expresiones usando una sintaxis similar a las listas por comprensión pero con
paréntesis en vez de corchetes.  Estas expresiones se utilizan en
situaciones donde el generador es usado inmediatamente por una función que
lo contiene.  Las expresiones generadoras son más compactas pero menos
versátiles que definiciones completas de generadores, y tienden a utilizar
menos memoria que las listas por comprensión equivalentes.</p>
<p>Ejemplos:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c"># suma de cuadrados</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c"># producto escalar</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tabla_de_senos</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">91</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">palabras_unicas</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span>  <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mejor_promedio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">alumno</span><span class="o">.</span><span class="n">promedio</span><span class="p">,</span> <span class="n">alumno</span><span class="o">.</span><span class="n">nombre</span><span class="p">)</span> <span class="k">for</span> <span class="n">alumno</span> <span class="ow">in</span> <span class="n">graduados</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Excepto por un detalle. Los objetos módulo tienen un atributo secreto de
solo lectura llamado <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> que devuelve el diccionario usado para
implementar el espacio de nombres del módulo; el nombre <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> es
un atributo, pero no es un nombre global.  Obviamente, esto viola la
abstracción de la implementación de espacios de nombres, y debe ser
restringido a cosas tales como depuradores post-mortem.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="contenido.html">Contenidos</a></h3>
            <ul>
<li><a class="reference external" href="#">10. Clases</a><ul>
<li><a class="reference external" href="#unas-palabras-sobre-nombres-y-objetos">10.1. Unas palabras sobre nombres y objetos</a></li>
<li><a class="reference external" href="#alcances-y-espacios-de-nombres-en-python">10.2. Alcances y espacios de nombres en Python</a></li>
<li><a class="reference external" href="#un-primer-vistazo-a-las-clases">10.3. Un primer vistazo a las clases</a><ul>
<li><a class="reference external" href="#sintaxis-de-definicion-de-clases">10.3.1. Sintaxis de definición de clases</a></li>
<li><a class="reference external" href="#objetos-clase">10.3.2. Objetos clase</a></li>
<li><a class="reference external" href="#objetos-instancia">10.3.3. Objetos instancia</a></li>
<li><a class="reference external" href="#objetos-metodo">10.3.4. Objetos método</a></li>
</ul>
</li>
<li><a class="reference external" href="#algunas-observaciones">10.4. Algunas observaciones</a></li>
<li><a class="reference external" href="#herencia">10.5. Herencia</a><ul>
<li><a class="reference external" href="#herencia-multiple">10.5.1. Herencia múltiple</a></li>
</ul>
</li>
<li><a class="reference external" href="#variables-privadas">10.6. Variables privadas</a></li>
<li><a class="reference external" href="#cambalache">10.7. Cambalache</a></li>
<li><a class="reference external" href="#las-excepciones-tambien-son-clases">10.8. Las excepciones también son clases</a></li>
<li><a class="reference external" href="#iteradores">10.9. Iteradores</a></li>
<li><a class="reference external" href="#generadores">10.10. Generadores</a></li>
<li><a class="reference external" href="#expresiones-generadoras">10.11. Expresiones generadoras</a></li>
</ul>
</li>
</ul>

            <h4>Tema anterior</h4>
            <p class="topless"><a href="errors.html"
                                  title="Capítulo anterior">9. Errores y excepciones</a></p>
            <h4>Próximo tema</h4>
            <p class="topless"><a href="stdlib.html"
                                  title="Próximo capítulo">11. Pequeño paseo por la Biblioteca Estándar</a></p>
            <h3>Esta página</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/classes.txt"
                     rel="nofollow">Enseñar el código</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Búsqueda rápida</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Ir a" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Ingrese una palabra para buscar o un nombre de módulo, clase o función
              </p>
          </div>
          <h4><a href="/"> Volver a CdPedia </a></h4>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="stdlib.html" title="11. Pequeño paseo por la Biblioteca Estándar"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="errors.html" title="9. Errores y excepciones"
             >anterior</a> |</li>
        <li><a href="contenido.html">Tutorial de Python v2.6.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, Python Software Foundation.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>
